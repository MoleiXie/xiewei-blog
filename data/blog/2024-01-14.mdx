---
title: Vue - 权衡的艺术
date: '2024-01-14'
tags: ['vue']
draft: false
summary: '框架的设计包含各类权衡利弊，命令式与编程式？极致的性能与可维护性？运行时或编译时？'
---

<TOCInline toc={props.toc} exclude="Introduction" />

## 权衡的艺术

> 框架设计里到处都体现着权衡的艺术

在学习框架时，应该从全局的角度对框架的设计拥有清晰的认知，否则容易陷入细节的误区，看不清全貌。

在Vue.js的设计与实现中，有以下几个需要权衡的问题：

- 框架设计应当是**声明式**还是**命令式**？可否取两者优点？

- **极致的性能**与**可维护性**之间改如何取舍呢？如何两者取其精华？

- **运行时（runtime）**or**编译时（compile-time）**or**运行+编译**？差异如何？优缺点？

## 命令式与声明式

`jQuery`典型的命令式框架，**关注过程**，具体实例：

- 获取id为app的div标签
- 设置文本内容为Hello world
- 绑定点击事件
- 点击时弹出 ok

```js
$('#app')					// 获取id为app的节点
	.text('hello world')	 // 设置文本为Hello world
	.on('click', () => {	 // 绑定点击事件
    	alert('ok')			 // 弹出提示 ok
	})
```

这里自然语言与代码一一对应，描述的就是`做事的过程`符合逻辑直觉。



`Vue.js`声明式变成，更**关注结果**，具体实现：

```Html
<div @click="() => alert('ok')">Hello world</div>
```

不用去关心如何去实现，`Vue.js`帮我们完成了**过程**，内部实现一定是命令式的，而暴露出来的却是**声明式**。


## 性能与可维护性的权衡

声明式与命令式各有优缺点，在设计方面，差异体现在**性能与可维护性之间的权衡**。

直接上结论：
> 声明式代码的性能不优于命令式代码的性能 (声明式 < 命令式)

假如我们要修改`div`标签的文本内容为`hello world123`，命令实现：
```js
div.textContent = 'hello world123';	// 直接修改
```

没有比上面代码性能更好的了，理论上命令式代码可以做到极致的性能优化。

声明实现：

```diff-js:html
// 之前
- <div @click="() => alert('ok')">Hello world</div>
// 之后
+ <div @click="() => alert('ok')">Hello world123</div>

// 最终框架内部还是会执行这句表达式
div.textContent = 'hello world123';
```

对于框架而言，为了实现最优的**更新性能**，他会对比只更新需要变化的的地方。

设**直接修改消耗**的性能为 **A**，**找出差异的性能**消耗为 **B**，可以得知：

- 命令式消耗性能 = A 
- 声明式消耗性能 = A + B

可以明显得到我们前面所说的结论，`声明式代码的性能不优于命令式代码的性能`

那为什么不选择性能更好的命令式呢？

从之前命令式与声明式的对比看来，命令式需要我们自己去**维护DOM，创建、销毁、更新**的过程。而在Vue.js内部已经帮我们完成了这样命令式的操作，只需要展示结果，看上去更加直观。这就体现了，可维护性与性能之间的权衡。而框架设计者要做的就是：

如何在保持可维护性的前提下，最小化的降低损失的性能？


## 虚拟DOM的性能对比

从上一小节我们得到：

​	**声明式代码性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**

而虚拟DOM就是为了**最小化找出差异的性能消耗**所出现的

 	- 理论上，采用**虚拟DOM**的更新性能完全比不上 **Js 操作 DOM**
 	
 	- 但是，我们绝大部分情况，都很难写出**绝对性能优化**的代码，即使写出也需要耗费巨大的精力，性价比不高

如何不耗费巨大精力，还能保证应用性能，甚至逼近原生性能，这就是**虚拟DOM**要解决的问题

首先我们要进行区分：
- 原生 Js：`document.createElement`等<br/>
- 特殊：`innerHTML`

### 创建过程：

1. 使用`innerHTML`进行创建：
   - 构造字符串	`const html = "<div>hello</div>"`
   - 赋值DOM元素     `div.innerHTML = html`
   - 字符串解析为DOM树

得到 `innerHTML`性能 = `HTML`字符串拼接计算 + `innerHTML`的DOM技术

2. 使用`虚拟DOM`创建：
   - 创建 Js 对象
   - 新建所有DOM

看起里没有优势可言，甚至会更差

### 更新过程：

​	`innerHTML`销毁所有DOM元素，全量创建新DOM元素

​	`虚拟DOM`重写创建 Js 对象，对比更新

列表进行对比：
|          | 虚拟DOM | innerHTML |
| -------- | :---------------------- | :------------------ |
| **纯Js操作** | 创建虚拟DOM + Diff对比 | 渲染 HTML字符串 |
| **DOM计算**  | 必要DOM更新 | 销毁所有、创建所有 |
| **性能因素** | 与数据变化相关 | 与模板大小相关     |

最终对比：
|    innerHTML      | 虚拟DOM | 原生JS |
| :-------- | :---------------------- | :------------------ |
| 心智负担中等 | 心智负担小 | 心智负担大 |
| 可维护性中等  | 可维护性强 | 可维护性差 |
| 性能差 | 性能不错 | 性能最佳     |

性能结论：`innerHTML` < `虚拟DOM` < `innerHTML`